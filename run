#!/usr/bin/env python3

"""
Monorepo management scripts.

Usage:
    python run lint              # Run linting and formatting for all packages in current directory
    python run lint [pkg|path]   # Run linting and formatting for package, path, or file
    python run test              # Run tests for all packages in current directory
    python run test [pkg]        # Run tests for specified package
    python run build             # Build all packages in current directory
    python run build [pkg]       # Build specified package
    python run build -i [pkg]    # Build and install specified package
    python run clean             # Remove build files for all packages in current directory
    python run clean [pkg]       # Remove build files for specified package
    python run publish [pkg]     # Publish specified package to PyPI
    python run hooks install     # Install `pre-commit` hooks
    python run hooks uninstall   # Uninstall `pre-commit` hooks
    python run hooks update      # Update `pre-commit` hooks
    python run hooks run         # Run `pre-commit` hooks on all files
"""

import sys
from argparse import ArgumentParser, RawDescriptionHelpFormatter

from scripts import build, clean, common, hooks, lint, publish, test

PACKAGES = common.PACKAGES
PACKAGES_DIR = common.PACKAGES_DIR
ROOT_DIR = common.ROOT_DIR


def main():
    parser = ArgumentParser(
        description="Monorepo management scripts",
        formatter_class=RawDescriptionHelpFormatter,
        epilog="""
Examples:
    python run hooks install
    python run hooks update
    python run hooks run
    python run lint
    python run lint cpf-fmt
    python run test
    python run test cnpj-gen
    python run build
    python run build cnpj-val
    python run build --install-afterwards cpf-utils
    python run build -i cnpj-utils
    python run clean
    python run clean cpf-fmt
    python run publish cpf-gen
""",
    )

    subparsers = parser.add_subparsers(dest="command", help="Command to execute")

    hooks.setup_commands(subparsers)
    lint.setup_commands(subparsers)
    test.setup_commands(subparsers)
    build.setup_commands(subparsers)
    clean.setup_commands(subparsers)
    publish.setup_commands(subparsers)

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    if args.command == "hooks":
        if not args.hooks_command:
            parser.parse_args([args.command, "--help"])
            sys.exit(1)

        if args.hooks_command == "install":
            sys.exit(0) if hooks.install_hooks() else sys.exit(1)

        if args.hooks_command == "uninstall":
            sys.exit(0) if hooks.uninstall_hooks() else sys.exit(1)

        if args.hooks_command == "update":
            sys.exit(0) if hooks.update_hooks() else sys.exit(1)

        if args.hooks_command == "run":
            sys.exit(0) if hooks.run_hooks() else sys.exit(1)

        parser.parse_args([args.command, "--help"])
        sys.exit(1)

    if args.command == "lint":
        is_all_mode = not args.package

        if is_all_mode:
            sys.exit(0) if lint.lint_all() else sys.exit(1)

        resolved_paths = []

        for pkg_arg in args.package:
            resolved_path = common.resolve_path(pkg_arg)

            if resolved_path is None:
                print(f"Error: '{pkg_arg}' is not a valid package, path, or file.")
                print(f"Available packages: {', '.join(PACKAGES)}")
                sys.exit(1)

            resolved_paths.append(resolved_path)

        sys.exit(0) if lint.lint_files(resolved_paths) else sys.exit(1)

    if args.command == "test":
        is_all_mode = not args.package
        is_watch_mode = hasattr(args, "watch") and args.watch
        is_quiet_mode = hasattr(args, "quiet") and args.quiet
        is_verbose_mode = hasattr(args, "verbose") and args.verbose

        if is_watch_mode:
            test.test_watch(
                package=args.package,
                quiet=is_quiet_mode,
                verbose=is_verbose_mode,
            )
            sys.exit(0)

        if is_all_mode:
            (
                sys.exit(0)
                if test.test_all(quiet=is_quiet_mode, verbose=is_verbose_mode)
                else sys.exit(1)
            )

        if args.package not in PACKAGES:
            print(f"Error: Package '{args.package}' not found.")
            print(f"Available packages: {', '.join(PACKAGES)}")
            sys.exit(1)

        pkg_path = PACKAGES_DIR / args.package

        (
            sys.exit(0)
            if test.test_package(
                pkg_path,
                quiet=is_quiet_mode,
                verbose=is_verbose_mode,
            )
            else sys.exit(1)
        )

    if args.command == "build":
        is_all_mode = not args.package
        version = getattr(args, "version", None)
        is_quiet_mode = hasattr(args, "quiet") and args.quiet
        is_install_afterwards_mode = (
            hasattr(args, "install_afterwards") and args.install_afterwards
        )

        if is_all_mode:
            (
                sys.exit(0)
                if build.build_all(
                    install_afterwards=is_install_afterwards_mode,
                    quiet=is_quiet_mode,
                    version=version,
                )
                else sys.exit(1)
            )

        if args.package not in PACKAGES:
            print(f"Error: Package '{args.package}' not found.")
            print(f"Available packages: {', '.join(PACKAGES)}")
            sys.exit(1)

        pkg_path = PACKAGES_DIR / args.package

        if is_quiet_mode:
            with common.Spinner(f"Building packages: {args.package}"):
                success = build.build_package(
                    pkg_path,
                    install_afterwards=args.install_afterwards,
                    quiet=is_quiet_mode,
                    version=version,
                )

            max_length = max(len(f"Building packages: {args.package}") + 10, 100)
            print("\r" + " " * max_length + "\r", end="", flush=True)

            if not success:
                print(f"❌ {args.package}")
                sys.exit(1)

            print(f"✅ {args.package}")
            sys.exit(0)

        (
            sys.exit(0)
            if build.build_package(
                pkg_path,
                install_afterwards=args.install_afterwards,
                quiet=is_quiet_mode,
                version=version,
            )
            else sys.exit(1)
        )

    if args.command == "clean":
        is_all_mode = not args.package

        if is_all_mode:
            clean.clean_all()
            sys.exit(0)

        if args.package not in PACKAGES:
            print(f"Error: Package '{args.package}' not found.")
            print(f"Available packages: {', '.join(PACKAGES)}")
            sys.exit(1)

        pkg_path = PACKAGES_DIR / args.package

        clean.clean_package(pkg_path)
        sys.exit(0)

    if args.command == "publish":
        if args.package not in PACKAGES:
            print(f"Error: Package '{args.package}' not found.")
            print(f"Available packages: {', '.join(PACKAGES)}")
            sys.exit(1)

        pkg_path = PACKAGES_DIR / args.package

        sys.exit(0) if publish.publish_package(pkg_path) else sys.exit(1)

    parser.print_help()
    sys.exit(1)


if __name__ == "__main__":
    main()

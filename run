#!/usr/bin/env python3

"""
Monorepo management scripts.

Usage:
    python run lint              # Run linting and formatting for all packages in current directory
    python run lint [pkg|path]   # Run linting and formatting for package, path, or file
    python run test              # Run tests for all packages in current directory
    python run test [pkg]        # Run tests for specified package
    python run build             # Build all packages in current directory
    python run build [pkg]       # Build specified package
    python run build -i [pkg]    # Build and install specified package
    python run clean             # Remove build files for all packages in current directory
    python run clean [pkg]       # Remove build files for specified package
    python run publish [pkg]     # Publish specified package to PyPI
    python run hooks install     # Install `pre-commit` hooks
    python run hooks uninstall   # Uninstall `pre-commit` hooks
    python run hooks update      # Update `pre-commit` hooks
    python run hooks run         # Run `pre-commit` hooks on all files
"""

import sys
from argparse import ArgumentParser, RawDescriptionHelpFormatter

from scripts import build, clean, common, hooks, lint, publish, test

PACKAGES = common.PACKAGES
PACKAGES_DIR = common.PACKAGES_DIR
ROOT_DIR = common.ROOT_DIR


def main():
    parser = ArgumentParser(
        description="Monorepo management scripts",
        formatter_class=RawDescriptionHelpFormatter,
        epilog="""
Examples:
    python run hooks install
    python run hooks update
    python run hooks run
    python run lint
    python run lint cpf-fmt
    python run test
    python run test cnpj-gen
    python run build
    python run build cnpj-val
    python run build --install-afterwards cpf-utils
    python run build -i cnpj-utils
    python run clean
    python run clean cpf-fmt
    python run publish cpf-gen
""",
    )

    subparsers = parser.add_subparsers(dest="command", help="Command to execute")

    hooks.setup_commands(subparsers)
    lint.setup_commands(subparsers)
    test.setup_commands(subparsers)
    build.setup_commands(subparsers)
    clean.setup_commands(subparsers)
    publish.setup_commands(subparsers)

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    if args.command == "test":
        if hasattr(args, "watch") and args.watch:
            test.test_watch(
                package=args.package,
                quiet=hasattr(args, "quiet") and args.quiet,
                verbose=hasattr(args, "verbose") and args.verbose,
            )
        elif args.package:
            if args.package not in PACKAGES:
                print(f"Error: Package '{args.package}' not found.")
                print(f"Available packages: {', '.join(PACKAGES)}")
                sys.exit(1)

            pkg_path = PACKAGES_DIR / args.package

            if not test.test_package(
                pkg_path,
                quiet=hasattr(args, "quiet") and args.quiet,
                verbose=hasattr(args, "verbose") and args.verbose,
            ):
                sys.exit(1)
        else:
            test.test_all(
                quiet=hasattr(args, "quiet") and args.quiet,
                verbose=hasattr(args, "verbose") and args.verbose,
            )

    elif args.command == "test-all":
        test.test_all(
            quiet=hasattr(args, "quiet") and args.quiet,
            verbose=hasattr(args, "verbose") and args.verbose,
        )

    elif args.command == "build":
        quiet_mode = hasattr(args, "quiet") and args.quiet

        if args.package:
            if args.package not in PACKAGES:
                print(f"Error: Package '{args.package}' not found.")
                print(f"Available packages: {', '.join(PACKAGES)}")
                sys.exit(1)

            pkg_path = PACKAGES_DIR / args.package

            if quiet_mode:
                from .scripts.common import Spinner

                with Spinner(f"Building packages: {args.package}"):
                    success = build.build_package(
                        pkg_path,
                        install_afterwards=args.install_afterwards,
                        quiet=quiet_mode,
                    )

                max_length = max(len(f"Building packages: {args.package}") + 10, 100)
                print("\r" + " " * max_length + "\r", end="", flush=True)

                if success:
                    print(f"✅ {args.package}")
                else:
                    print(f"❌ {args.package}")
                    sys.exit(1)
            else:
                if not build.build_package(
                    pkg_path,
                    install_afterwards=args.install_afterwards,
                    quiet=quiet_mode,
                ):
                    sys.exit(1)
        else:
            build.build_all(
                install_afterwards=args.install_afterwards,
                quiet=quiet_mode,
            )

    elif args.command == "publish":
        if args.package not in PACKAGES:
            print(f"Error: Package '{args.package}' not found.")
            print(f"Available packages: {', '.join(PACKAGES)}")
            sys.exit(1)

        pkg_path = PACKAGES_DIR / args.package

        if not publish.publish_package(pkg_path):
            sys.exit(1)

    elif args.command == "clean":
        if args.package:
            if args.package not in PACKAGES:
                print(f"Error: Package '{args.package}' not found.")
                print(f"Available packages: {', '.join(PACKAGES)}")
                sys.exit(1)

            pkg_path = PACKAGES_DIR / args.package
            clean.clean_package(pkg_path)
        else:
            clean.clean_all()

    elif args.command == "lint":
        if args.package:
            resolved_paths = []

            for pkg_arg in args.package:
                resolved_path = common.resolve_path(pkg_arg)

                if resolved_path is None:
                    print(f"Error: '{pkg_arg}' is not a valid package, path, or file.")
                    print(f"Available packages: {', '.join(PACKAGES)}")
                    sys.exit(1)

                resolved_paths.append(resolved_path)

            if not lint.lint_files(resolved_paths):
                sys.exit(1)
        else:
            if not lint.lint_all():
                sys.exit(1)

    elif args.command == "hooks":
        if not args.hooks_command:
            parser.parse_args([args.command, "--help"])
            sys.exit(1)

        if args.hooks_command == "install":
            if not hooks.install_hooks():
                sys.exit(1)
        elif args.hooks_command == "uninstall":
            if not hooks.uninstall_hooks():
                sys.exit(1)
        elif args.hooks_command == "update":
            if not hooks.update_hooks():
                sys.exit(1)
        elif args.hooks_command == "run":
            if not hooks.run_hooks():
                sys.exit(1)
        else:
            parser.parse_args([args.command, "--help"])
            sys.exit(1)

    else:
        parser.print_help()
        sys.exit(1)


if __name__ == "__main__":
    main()
